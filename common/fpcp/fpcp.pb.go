// Code generated by protoc-gen-go. DO NOT EDIT.
// source: fpcp.proto

/*
Package fpcp is a generated protocol buffer package.

It is generated from these files:
	fpcp.proto

It has these top-level messages:
	Void
	Size
	Rectangle
	AuthToken
	Scene
	Frame
	Face
	Picture
*/
package fpcp

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Picture_Format int32

const (
	Picture_RAW Picture_Format = 0
	Picture_PNG Picture_Format = 1
	Picture_JPG Picture_Format = 2
)

var Picture_Format_name = map[int32]string{
	0: "RAW",
	1: "PNG",
	2: "JPG",
}
var Picture_Format_value = map[string]int32{
	"RAW": 0,
	"PNG": 1,
	"JPG": 2,
}

func (x Picture_Format) String() string {
	return proto.EnumName(Picture_Format_name, int32(x))
}
func (Picture_Format) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{7, 0} }

// Just use it like an empty message
type Void struct {
}

func (m *Void) Reset()                    { *m = Void{} }
func (m *Void) String() string            { return proto.CompactTextString(m) }
func (*Void) ProtoMessage()               {}
func (*Void) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Size struct {
	Width  uint32 `protobuf:"varint,1,opt,name=width" json:"width,omitempty"`
	Height uint32 `protobuf:"varint,2,opt,name=height" json:"height,omitempty"`
}

func (m *Size) Reset()                    { *m = Size{} }
func (m *Size) String() string            { return proto.CompactTextString(m) }
func (*Size) ProtoMessage()               {}
func (*Size) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Size) GetWidth() uint32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *Size) GetHeight() uint32 {
	if m != nil {
		return m.Height
	}
	return 0
}

type Rectangle struct {
	Left   int32 `protobuf:"varint,1,opt,name=left" json:"left,omitempty"`
	Top    int32 `protobuf:"varint,2,opt,name=top" json:"top,omitempty"`
	Right  int32 `protobuf:"varint,3,opt,name=right" json:"right,omitempty"`
	Bottom int32 `protobuf:"varint,4,opt,name=bottom" json:"bottom,omitempty"`
}

func (m *Rectangle) Reset()                    { *m = Rectangle{} }
func (m *Rectangle) String() string            { return proto.CompactTextString(m) }
func (*Rectangle) ProtoMessage()               {}
func (*Rectangle) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Rectangle) GetLeft() int32 {
	if m != nil {
		return m.Left
	}
	return 0
}

func (m *Rectangle) GetTop() int32 {
	if m != nil {
		return m.Top
	}
	return 0
}

func (m *Rectangle) GetRight() int32 {
	if m != nil {
		return m.Right
	}
	return 0
}

func (m *Rectangle) GetBottom() int32 {
	if m != nil {
		return m.Bottom
	}
	return 0
}

type AuthToken struct {
	Access string `protobuf:"bytes,1,opt,name=access" json:"access,omitempty"`
	Secret string `protobuf:"bytes,2,opt,name=secret" json:"secret,omitempty"`
}

func (m *AuthToken) Reset()                    { *m = AuthToken{} }
func (m *AuthToken) String() string            { return proto.CompactTextString(m) }
func (*AuthToken) ProtoMessage()               {}
func (*AuthToken) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *AuthToken) GetAccess() string {
	if m != nil {
		return m.Access
	}
	return ""
}

func (m *AuthToken) GetSecret() string {
	if m != nil {
		return m.Secret
	}
	return ""
}

type Scene struct {
	// The scene identificator. FP changes it when considers new scene
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The timestampt indicastes when FP catches the scene
	Since uint64 `protobuf:"varint,2,opt,name=since" json:"since,omitempty"`
	// Number of persons on the scene. Current frame can contain another
	// number of faces (equal or less than reported), this is because not
	// all faces can be detected at the time
	Persons int32 `protobuf:"varint,3,opt,name=persons" json:"persons,omitempty"`
	// Current frame, contains image of the scene
	Frame *Frame `protobuf:"bytes,4,opt,name=frame" json:"frame,omitempty"`
	// list of faces catched on the frame. This list can contain NOT ALL scene
	// persons, but only that catched on the frame. so the number of faces in the list
	// can be less than expected (persons)
	Faces []*Face `protobuf:"bytes,5,rep,name=faces" json:"faces,omitempty"`
}

func (m *Scene) Reset()                    { *m = Scene{} }
func (m *Scene) String() string            { return proto.CompactTextString(m) }
func (*Scene) ProtoMessage()               {}
func (*Scene) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Scene) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Scene) GetSince() uint64 {
	if m != nil {
		return m.Since
	}
	return 0
}

func (m *Scene) GetPersons() int32 {
	if m != nil {
		return m.Persons
	}
	return 0
}

func (m *Scene) GetFrame() *Frame {
	if m != nil {
		return m.Frame
	}
	return nil
}

func (m *Scene) GetFaces() []*Face {
	if m != nil {
		return m.Faces
	}
	return nil
}

type Frame struct {
	Id        string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Timestamp uint64 `protobuf:"varint,2,opt,name=timestamp" json:"timestamp,omitempty"`
	// the frame size taken from the camera. Pictures can be resized, but this one is true size
	Size *Size `protobuf:"bytes,3,opt,name=size" json:"size,omitempty"`
	// images of the frame, can be encoded in different sizes and compression types
	Pictures []*Picture `protobuf:"bytes,4,rep,name=pictures" json:"pictures,omitempty"`
}

func (m *Frame) Reset()                    { *m = Frame{} }
func (m *Frame) String() string            { return proto.CompactTextString(m) }
func (*Frame) ProtoMessage()               {}
func (*Frame) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Frame) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Frame) GetTimestamp() uint64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Frame) GetSize() *Size {
	if m != nil {
		return m.Size
	}
	return nil
}

func (m *Frame) GetPictures() []*Picture {
	if m != nil {
		return m.Pictures
	}
	return nil
}

// Face on the frame. Can contain list of pictures encoded into different sizes
type Face struct {
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The position of the face on the origianl frame
	Rect   *Rectangle `protobuf:"bytes,2,opt,name=rect" json:"rect,omitempty"`
	Vector []float32  `protobuf:"fixed32,3,rep,packed,name=vector" json:"vector,omitempty"`
	// Pictures of the face. Can be empty. The pictures are cuts from the frame and their size
	// can be different that the original
	Pictures []*Picture `protobuf:"bytes,4,rep,name=pictures" json:"pictures,omitempty"`
}

func (m *Face) Reset()                    { *m = Face{} }
func (m *Face) String() string            { return proto.CompactTextString(m) }
func (*Face) ProtoMessage()               {}
func (*Face) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Face) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Face) GetRect() *Rectangle {
	if m != nil {
		return m.Rect
	}
	return nil
}

func (m *Face) GetVector() []float32 {
	if m != nil {
		return m.Vector
	}
	return nil
}

func (m *Face) GetPictures() []*Picture {
	if m != nil {
		return m.Pictures
	}
	return nil
}

// The picture message keeps information about a compressed picture
type Picture struct {
	// The picture size.
	Size *Size `protobuf:"bytes,1,opt,name=size" json:"size,omitempty"`
	// code one of the following: t, s, m, l, o
	SizeCode int32 `protobuf:"varint,2,opt,name=sizeCode" json:"sizeCode,omitempty"`
	// compression type
	Format Picture_Format `protobuf:"varint,3,opt,name=format,enum=fpcp.Picture_Format" json:"format,omitempty"`
	// actual picture data
	Data []byte `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *Picture) Reset()                    { *m = Picture{} }
func (m *Picture) String() string            { return proto.CompactTextString(m) }
func (*Picture) ProtoMessage()               {}
func (*Picture) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *Picture) GetSize() *Size {
	if m != nil {
		return m.Size
	}
	return nil
}

func (m *Picture) GetSizeCode() int32 {
	if m != nil {
		return m.SizeCode
	}
	return 0
}

func (m *Picture) GetFormat() Picture_Format {
	if m != nil {
		return m.Format
	}
	return Picture_RAW
}

func (m *Picture) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func init() {
	proto.RegisterType((*Void)(nil), "fpcp.Void")
	proto.RegisterType((*Size)(nil), "fpcp.Size")
	proto.RegisterType((*Rectangle)(nil), "fpcp.Rectangle")
	proto.RegisterType((*AuthToken)(nil), "fpcp.AuthToken")
	proto.RegisterType((*Scene)(nil), "fpcp.Scene")
	proto.RegisterType((*Frame)(nil), "fpcp.Frame")
	proto.RegisterType((*Face)(nil), "fpcp.Face")
	proto.RegisterType((*Picture)(nil), "fpcp.Picture")
	proto.RegisterEnum("fpcp.Picture_Format", Picture_Format_name, Picture_Format_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for SceneProcessorService service

type SceneProcessorServiceClient interface {
	// Authenticates the client. Server will respond appropriate "session_id" or "error".
	Authenticate(ctx context.Context, in *AuthToken, opts ...grpc.CallOption) (*Void, error)
	// Sends the client scene information.
	OnScene(ctx context.Context, in *Scene, opts ...grpc.CallOption) (*Void, error)
}

type sceneProcessorServiceClient struct {
	cc *grpc.ClientConn
}

func NewSceneProcessorServiceClient(cc *grpc.ClientConn) SceneProcessorServiceClient {
	return &sceneProcessorServiceClient{cc}
}

func (c *sceneProcessorServiceClient) Authenticate(ctx context.Context, in *AuthToken, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/fpcp.SceneProcessorService/authenticate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sceneProcessorServiceClient) OnScene(ctx context.Context, in *Scene, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/fpcp.SceneProcessorService/onScene", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for SceneProcessorService service

type SceneProcessorServiceServer interface {
	// Authenticates the client. Server will respond appropriate "session_id" or "error".
	Authenticate(context.Context, *AuthToken) (*Void, error)
	// Sends the client scene information.
	OnScene(context.Context, *Scene) (*Void, error)
}

func RegisterSceneProcessorServiceServer(s *grpc.Server, srv SceneProcessorServiceServer) {
	s.RegisterService(&_SceneProcessorService_serviceDesc, srv)
}

func _SceneProcessorService_Authenticate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthToken)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SceneProcessorServiceServer).Authenticate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/fpcp.SceneProcessorService/Authenticate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SceneProcessorServiceServer).Authenticate(ctx, req.(*AuthToken))
	}
	return interceptor(ctx, in, info, handler)
}

func _SceneProcessorService_OnScene_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Scene)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SceneProcessorServiceServer).OnScene(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/fpcp.SceneProcessorService/OnScene",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SceneProcessorServiceServer).OnScene(ctx, req.(*Scene))
	}
	return interceptor(ctx, in, info, handler)
}

var _SceneProcessorService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "fpcp.SceneProcessorService",
	HandlerType: (*SceneProcessorServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "authenticate",
			Handler:    _SceneProcessorService_Authenticate_Handler,
		},
		{
			MethodName: "onScene",
			Handler:    _SceneProcessorService_OnScene_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "fpcp.proto",
}

func init() { proto.RegisterFile("fpcp.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 503 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x53, 0x41, 0x6f, 0x13, 0x3d,
	0x10, 0xfd, 0x36, 0xeb, 0x4d, 0x9a, 0x49, 0xdb, 0x2f, 0xb2, 0x0a, 0x5a, 0x55, 0x08, 0x85, 0xed,
	0x25, 0x08, 0x94, 0x43, 0xe0, 0xc6, 0xa9, 0x42, 0x6a, 0x25, 0x0e, 0x28, 0x72, 0x10, 0x1c, 0x91,
	0xeb, 0x9d, 0x74, 0x2d, 0xba, 0xeb, 0x95, 0xed, 0x14, 0xa9, 0x07, 0xc4, 0x0f, 0xe0, 0xa7, 0xf0,
	0x23, 0x91, 0xc7, 0x66, 0x01, 0x55, 0x1c, 0x38, 0xed, 0xbc, 0x37, 0x33, 0x3b, 0xcf, 0xe3, 0x67,
	0x80, 0x5d, 0xaf, 0xfa, 0x55, 0x6f, 0x8d, 0x37, 0x9c, 0x85, 0xb8, 0x1a, 0x03, 0x7b, 0x6f, 0x74,
	0x5d, 0xbd, 0x04, 0xb6, 0xd5, 0x77, 0xc8, 0x4f, 0xa0, 0xf8, 0xac, 0x6b, 0xdf, 0x94, 0xd9, 0x22,
	0x5b, 0x1e, 0x89, 0x08, 0xf8, 0x43, 0x18, 0x37, 0xa8, 0xaf, 0x1b, 0x5f, 0x8e, 0x88, 0x4e, 0xa8,
	0xfa, 0x08, 0x53, 0x81, 0xca, 0xcb, 0xee, 0xfa, 0x06, 0x39, 0x07, 0x76, 0x83, 0x3b, 0x4f, 0x9d,
	0x85, 0xa0, 0x98, 0xcf, 0x21, 0xf7, 0xa6, 0xa7, 0xae, 0x42, 0x84, 0x30, 0x0c, 0xb0, 0xf4, 0xa7,
	0x9c, 0xb8, 0x08, 0xc2, 0x80, 0x2b, 0xe3, 0xbd, 0x69, 0x4b, 0x46, 0x74, 0x42, 0xd5, 0x2b, 0x98,
	0x9e, 0xef, 0x7d, 0xf3, 0xce, 0x7c, 0xc2, 0x2e, 0x14, 0x49, 0xa5, 0xd0, 0x39, 0x1a, 0x31, 0x15,
	0x09, 0x05, 0xde, 0xa1, 0xb2, 0x18, 0xd5, 0x4d, 0x45, 0x42, 0xd5, 0xb7, 0x0c, 0x8a, 0xad, 0xc2,
	0x0e, 0xf9, 0x31, 0x8c, 0x74, 0x9d, 0xba, 0x46, 0xba, 0x0e, 0x22, 0x9c, 0xee, 0x14, 0x52, 0x03,
	0x13, 0x11, 0xf0, 0x12, 0x26, 0x3d, 0x5a, 0x67, 0x3a, 0x97, 0xc4, 0xfd, 0x84, 0xfc, 0x09, 0x14,
	0x3b, 0x2b, 0x5b, 0x24, 0x75, 0xb3, 0xf5, 0x6c, 0x45, 0x7b, 0xbc, 0x08, 0x94, 0x88, 0x19, 0xbe,
	0x80, 0x62, 0x27, 0x15, 0xba, 0xb2, 0x58, 0xe4, 0xcb, 0xd9, 0x1a, 0x52, 0x89, 0x54, 0xa1, 0x22,
	0x24, 0xaa, 0xaf, 0x19, 0x14, 0xd4, 0x72, 0x4f, 0xce, 0x23, 0x98, 0x7a, 0xdd, 0xa2, 0xf3, 0xb2,
	0xed, 0x93, 0xa4, 0x5f, 0x04, 0x7f, 0x0c, 0xcc, 0xe9, 0x3b, 0x24, 0x4d, 0xc3, 0x8f, 0xc3, 0x65,
	0x09, 0xe2, 0xf9, 0x53, 0x38, 0xe8, 0xb5, 0xf2, 0x7b, 0x8b, 0xae, 0x64, 0x34, 0xfc, 0x28, 0xd6,
	0x6c, 0x22, 0x2b, 0x86, 0x74, 0xf5, 0x05, 0x58, 0x50, 0x74, 0x4f, 0xc0, 0x19, 0x30, 0x8b, 0x2a,
	0xee, 0x6f, 0xb6, 0xfe, 0x3f, 0xb6, 0x0f, 0x37, 0x2b, 0x28, 0x19, 0xd6, 0x7c, 0x8b, 0xca, 0x1b,
	0x5b, 0xe6, 0x8b, 0x7c, 0x39, 0x12, 0x09, 0xfd, 0xcb, 0xfc, 0xef, 0x19, 0x4c, 0x12, 0x3b, 0x1c,
	0x2b, 0xfb, 0xcb, 0xb1, 0x4e, 0xe1, 0x20, 0x7c, 0x5f, 0x9b, 0x1a, 0x93, 0x7f, 0x06, 0xcc, 0x9f,
	0xc3, 0x78, 0x67, 0x6c, 0x2b, 0xa3, 0x8b, 0x8e, 0xd7, 0x27, 0x7f, 0x0c, 0x5c, 0x5d, 0x50, 0x4e,
	0xa4, 0x9a, 0x60, 0xcc, 0x5a, 0x7a, 0x49, 0x97, 0x77, 0x28, 0x28, 0xae, 0xce, 0x60, 0x1c, 0xab,
	0xf8, 0x04, 0x72, 0x71, 0xfe, 0x61, 0xfe, 0x5f, 0x08, 0x36, 0x6f, 0x2f, 0xe7, 0x59, 0x08, 0xde,
	0x6c, 0x2e, 0xe7, 0xa3, 0x75, 0x03, 0x0f, 0xc8, 0x3f, 0x1b, 0x6b, 0x82, 0xd1, 0x8c, 0xdd, 0xa2,
	0xbd, 0xd5, 0x0a, 0xf9, 0x33, 0x38, 0x94, 0x7b, 0xdf, 0x60, 0xe7, 0xb5, 0x92, 0x1e, 0x79, 0xda,
	0xd8, 0x60, 0xd5, 0xd3, 0x74, 0x9c, 0xf0, 0xb4, 0x78, 0x05, 0x13, 0xd3, 0x45, 0x1f, 0x26, 0xe3,
	0x10, 0xf8, 0xbd, 0xe6, 0x6a, 0x4c, 0x6f, 0xf2, 0xc5, 0x8f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xef,
	0xef, 0x15, 0x2e, 0xa1, 0x03, 0x00, 0x00,
}
