// Code generated by protoc-gen-go. DO NOT EDIT.
// source: fpcp.proto

/*
Package fpcp is a generated protocol buffer package.

It is generated from these files:
	fpcp.proto

It has these top-level messages:
	Void
	Size
	Rectangle
	AuthToken
	Scene
	Frame
	Face
*/
package fpcp

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Frame_Format int32

const (
	Frame_RAW Frame_Format = 0
	Frame_PNG Frame_Format = 1
)

var Frame_Format_name = map[int32]string{
	0: "RAW",
	1: "PNG",
}
var Frame_Format_value = map[string]int32{
	"RAW": 0,
	"PNG": 1,
}

func (x Frame_Format) String() string {
	return proto.EnumName(Frame_Format_name, int32(x))
}
func (Frame_Format) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{5, 0} }

// Just use it like an empty message
type Void struct {
}

func (m *Void) Reset()                    { *m = Void{} }
func (m *Void) String() string            { return proto.CompactTextString(m) }
func (*Void) ProtoMessage()               {}
func (*Void) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Size struct {
	Width  uint32 `protobuf:"varint,1,opt,name=width" json:"width,omitempty"`
	Height uint32 `protobuf:"varint,2,opt,name=height" json:"height,omitempty"`
}

func (m *Size) Reset()                    { *m = Size{} }
func (m *Size) String() string            { return proto.CompactTextString(m) }
func (*Size) ProtoMessage()               {}
func (*Size) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Size) GetWidth() uint32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *Size) GetHeight() uint32 {
	if m != nil {
		return m.Height
	}
	return 0
}

type Rectangle struct {
	Left   int32 `protobuf:"varint,1,opt,name=left" json:"left,omitempty"`
	Top    int32 `protobuf:"varint,2,opt,name=top" json:"top,omitempty"`
	Right  int32 `protobuf:"varint,3,opt,name=right" json:"right,omitempty"`
	Bottom int32 `protobuf:"varint,4,opt,name=bottom" json:"bottom,omitempty"`
}

func (m *Rectangle) Reset()                    { *m = Rectangle{} }
func (m *Rectangle) String() string            { return proto.CompactTextString(m) }
func (*Rectangle) ProtoMessage()               {}
func (*Rectangle) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Rectangle) GetLeft() int32 {
	if m != nil {
		return m.Left
	}
	return 0
}

func (m *Rectangle) GetTop() int32 {
	if m != nil {
		return m.Top
	}
	return 0
}

func (m *Rectangle) GetRight() int32 {
	if m != nil {
		return m.Right
	}
	return 0
}

func (m *Rectangle) GetBottom() int32 {
	if m != nil {
		return m.Bottom
	}
	return 0
}

type AuthToken struct {
	Access string `protobuf:"bytes,1,opt,name=access" json:"access,omitempty"`
	Secret string `protobuf:"bytes,2,opt,name=secret" json:"secret,omitempty"`
}

func (m *AuthToken) Reset()                    { *m = AuthToken{} }
func (m *AuthToken) String() string            { return proto.CompactTextString(m) }
func (*AuthToken) ProtoMessage()               {}
func (*AuthToken) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *AuthToken) GetAccess() string {
	if m != nil {
		return m.Access
	}
	return ""
}

func (m *AuthToken) GetSecret() string {
	if m != nil {
		return m.Secret
	}
	return ""
}

type Scene struct {
	// The scene identificator. FP changes it when considers new scene
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The timestampt indicastes when FP catches the scene
	Since uint64 `protobuf:"varint,2,opt,name=since" json:"since,omitempty"`
	// Number of persons on the scene. Current frame can contain another
	// number of faces (equal or less than reported), this is because not
	// all faces can be detected at the time
	Persons int32 `protobuf:"varint,3,opt,name=persons" json:"persons,omitempty"`
	// Current frame, contains image of the scene
	Frame *Frame `protobuf:"bytes,4,opt,name=frame" json:"frame,omitempty"`
	// list of faces catched on the frame. This list can contain NOT ALL scene
	// persons, but only that catched on the frame. so the number of faces in the list
	// can be less than expected (persons)
	Faces []*Face `protobuf:"bytes,5,rep,name=faces" json:"faces,omitempty"`
}

func (m *Scene) Reset()                    { *m = Scene{} }
func (m *Scene) String() string            { return proto.CompactTextString(m) }
func (*Scene) ProtoMessage()               {}
func (*Scene) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Scene) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Scene) GetSince() uint64 {
	if m != nil {
		return m.Since
	}
	return 0
}

func (m *Scene) GetPersons() int32 {
	if m != nil {
		return m.Persons
	}
	return 0
}

func (m *Scene) GetFrame() *Frame {
	if m != nil {
		return m.Frame
	}
	return nil
}

func (m *Scene) GetFaces() []*Face {
	if m != nil {
		return m.Faces
	}
	return nil
}

type Frame struct {
	Id        string       `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Timestamp uint64       `protobuf:"varint,2,opt,name=timestamp" json:"timestamp,omitempty"`
	Size      *Size        `protobuf:"bytes,3,opt,name=size" json:"size,omitempty"`
	Data      []byte       `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
	Format    Frame_Format `protobuf:"varint,5,opt,name=format,enum=fpcp.Frame_Format" json:"format,omitempty"`
}

func (m *Frame) Reset()                    { *m = Frame{} }
func (m *Frame) String() string            { return proto.CompactTextString(m) }
func (*Frame) ProtoMessage()               {}
func (*Frame) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Frame) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Frame) GetTimestamp() uint64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Frame) GetSize() *Size {
	if m != nil {
		return m.Size
	}
	return nil
}

func (m *Frame) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Frame) GetFormat() Frame_Format {
	if m != nil {
		return m.Format
	}
	return Frame_RAW
}

type Face struct {
	Id   string     `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Rect *Rectangle `protobuf:"bytes,2,opt,name=rect" json:"rect,omitempty"`
}

func (m *Face) Reset()                    { *m = Face{} }
func (m *Face) String() string            { return proto.CompactTextString(m) }
func (*Face) ProtoMessage()               {}
func (*Face) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Face) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Face) GetRect() *Rectangle {
	if m != nil {
		return m.Rect
	}
	return nil
}

func init() {
	proto.RegisterType((*Void)(nil), "fpcp.Void")
	proto.RegisterType((*Size)(nil), "fpcp.Size")
	proto.RegisterType((*Rectangle)(nil), "fpcp.Rectangle")
	proto.RegisterType((*AuthToken)(nil), "fpcp.AuthToken")
	proto.RegisterType((*Scene)(nil), "fpcp.Scene")
	proto.RegisterType((*Frame)(nil), "fpcp.Frame")
	proto.RegisterType((*Face)(nil), "fpcp.Face")
	proto.RegisterEnum("fpcp.Frame_Format", Frame_Format_name, Frame_Format_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for SceneProcessorService service

type SceneProcessorServiceClient interface {
	// Authenticates the client. Server will respond appropriate "session_id" or "error".
	Authenticate(ctx context.Context, in *AuthToken, opts ...grpc.CallOption) (*Void, error)
	// Sends the client scene information.
	OnScene(ctx context.Context, in *Scene, opts ...grpc.CallOption) (*Void, error)
}

type sceneProcessorServiceClient struct {
	cc *grpc.ClientConn
}

func NewSceneProcessorServiceClient(cc *grpc.ClientConn) SceneProcessorServiceClient {
	return &sceneProcessorServiceClient{cc}
}

func (c *sceneProcessorServiceClient) Authenticate(ctx context.Context, in *AuthToken, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/fpcp.SceneProcessorService/authenticate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sceneProcessorServiceClient) OnScene(ctx context.Context, in *Scene, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := grpc.Invoke(ctx, "/fpcp.SceneProcessorService/onScene", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for SceneProcessorService service

type SceneProcessorServiceServer interface {
	// Authenticates the client. Server will respond appropriate "session_id" or "error".
	Authenticate(context.Context, *AuthToken) (*Void, error)
	// Sends the client scene information.
	OnScene(context.Context, *Scene) (*Void, error)
}

func RegisterSceneProcessorServiceServer(s *grpc.Server, srv SceneProcessorServiceServer) {
	s.RegisterService(&_SceneProcessorService_serviceDesc, srv)
}

func _SceneProcessorService_Authenticate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthToken)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SceneProcessorServiceServer).Authenticate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/fpcp.SceneProcessorService/Authenticate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SceneProcessorServiceServer).Authenticate(ctx, req.(*AuthToken))
	}
	return interceptor(ctx, in, info, handler)
}

func _SceneProcessorService_OnScene_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Scene)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SceneProcessorServiceServer).OnScene(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/fpcp.SceneProcessorService/OnScene",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SceneProcessorServiceServer).OnScene(ctx, req.(*Scene))
	}
	return interceptor(ctx, in, info, handler)
}

var _SceneProcessorService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "fpcp.SceneProcessorService",
	HandlerType: (*SceneProcessorServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "authenticate",
			Handler:    _SceneProcessorService_Authenticate_Handler,
		},
		{
			MethodName: "onScene",
			Handler:    _SceneProcessorService_OnScene_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "fpcp.proto",
}

func init() { proto.RegisterFile("fpcp.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 432 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x64, 0x52, 0xc1, 0x6e, 0xd4, 0x30,
	0x10, 0x25, 0xbb, 0x71, 0x56, 0x99, 0x2d, 0x65, 0x65, 0x01, 0x8a, 0x2a, 0x84, 0x16, 0x73, 0x59,
	0x81, 0xb4, 0x87, 0xc0, 0xad, 0xa7, 0x5e, 0xca, 0x0d, 0x55, 0x5e, 0x04, 0x47, 0xe4, 0x3a, 0x93,
	0xc6, 0xa2, 0x89, 0x23, 0xdb, 0x05, 0xa9, 0xdf, 0xc0, 0xcf, 0xf0, 0x87, 0xc8, 0x63, 0xb3, 0x54,
	0xea, 0x6d, 0xde, 0x9b, 0x79, 0x9e, 0xe7, 0x99, 0x01, 0xe8, 0x67, 0x3d, 0xef, 0x67, 0x67, 0x83,
	0xe5, 0x65, 0x8c, 0x45, 0x05, 0xe5, 0x57, 0x6b, 0x3a, 0xf1, 0x11, 0xca, 0x83, 0xb9, 0x47, 0xfe,
	0x1c, 0xd8, 0x2f, 0xd3, 0x85, 0xa1, 0x29, 0xb6, 0xc5, 0xee, 0xa9, 0x4c, 0x80, 0xbf, 0x84, 0x6a,
	0x40, 0x73, 0x33, 0x84, 0x66, 0x41, 0x74, 0x46, 0xe2, 0x3b, 0xd4, 0x12, 0x75, 0x50, 0xd3, 0xcd,
	0x2d, 0x72, 0x0e, 0xe5, 0x2d, 0xf6, 0x81, 0x94, 0x4c, 0x52, 0xcc, 0x37, 0xb0, 0x0c, 0x76, 0x26,
	0x15, 0x93, 0x31, 0x8c, 0x0d, 0x1c, 0xbd, 0xb4, 0x24, 0x2e, 0x81, 0xd8, 0xe0, 0xda, 0x86, 0x60,
	0xc7, 0xa6, 0x24, 0x3a, 0x23, 0x71, 0x0e, 0xf5, 0xc5, 0x5d, 0x18, 0xbe, 0xd8, 0x1f, 0x38, 0xc5,
	0x22, 0xa5, 0x35, 0x7a, 0x4f, 0x2d, 0x6a, 0x99, 0x51, 0xe4, 0x3d, 0x6a, 0x87, 0xc9, 0x5d, 0x2d,
	0x33, 0x12, 0xbf, 0x0b, 0x60, 0x07, 0x8d, 0x13, 0xf2, 0x53, 0x58, 0x98, 0x2e, 0xab, 0x16, 0xa6,
	0x8b, 0x26, 0xbc, 0x99, 0x34, 0x92, 0xa0, 0x94, 0x09, 0xf0, 0x06, 0x56, 0x33, 0x3a, 0x6f, 0x27,
	0x9f, 0xcd, 0xfd, 0x83, 0xfc, 0x0d, 0xb0, 0xde, 0xa9, 0x11, 0xc9, 0xdd, 0xba, 0x5d, 0xef, 0x69,
	0x8e, 0x97, 0x91, 0x92, 0x29, 0xc3, 0xb7, 0xc0, 0x7a, 0xa5, 0xd1, 0x37, 0x6c, 0xbb, 0xdc, 0xad,
	0x5b, 0xc8, 0x25, 0x4a, 0xc7, 0x8a, 0x98, 0x10, 0x7f, 0x0a, 0x60, 0x24, 0x79, 0x64, 0xe7, 0x15,
	0xd4, 0xc1, 0x8c, 0xe8, 0x83, 0x1a, 0xe7, 0x6c, 0xe9, 0x3f, 0xc1, 0x5f, 0x43, 0xe9, 0xcd, 0x3d,
	0x92, 0xa7, 0xe3, 0xc3, 0x71, 0x59, 0x92, 0xf8, 0x38, 0xf7, 0x4e, 0x05, 0x45, 0xde, 0x4e, 0x24,
	0xc5, 0xfc, 0x1d, 0x54, 0xbd, 0x75, 0xa3, 0x0a, 0x0d, 0xdb, 0x16, 0xbb, 0xd3, 0x96, 0x3f, 0x70,
	0xbc, 0xbf, 0xa4, 0x8c, 0xcc, 0x15, 0xe2, 0x0c, 0xaa, 0xc4, 0xf0, 0x15, 0x2c, 0xe5, 0xc5, 0xb7,
	0xcd, 0x93, 0x18, 0x5c, 0x7d, 0xfe, 0xb4, 0x29, 0xc4, 0x39, 0x94, 0xf1, 0x0b, 0x8f, 0x1c, 0xbf,
	0x85, 0xd2, 0xa1, 0x4e, 0x03, 0x5f, 0xb7, 0xcf, 0xd2, 0xeb, 0xc7, 0x53, 0x90, 0x94, 0x6c, 0x07,
	0x78, 0x41, 0xe3, 0xbf, 0x72, 0x36, 0xee, 0xc9, 0xba, 0x03, 0xba, 0x9f, 0x46, 0x23, 0x7f, 0x0f,
	0x27, 0xea, 0x2e, 0x0c, 0x38, 0x05, 0xa3, 0x55, 0x40, 0x9e, 0xf5, 0xc7, 0x4d, 0x9f, 0xe5, 0x4f,
	0xc6, 0xcb, 0xe4, 0x02, 0x56, 0x76, 0x4a, 0x6b, 0xcc, 0x73, 0x27, 0xf0, 0xb0, 0xe6, 0xba, 0xa2,
	0x93, 0xfe, 0xf0, 0x37, 0x00, 0x00, 0xff, 0xff, 0x12, 0x80, 0xc6, 0xea, 0xe0, 0x02, 0x00, 0x00,
}
